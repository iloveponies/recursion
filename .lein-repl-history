(use 'recursion)
(use 'recursion :reload)
(product [])        ;=> 1  ; special case
(product [1 2 3])   ;=> 6
(product [1 2 3 4]) ;=> 24
(product [0 1 2])   ;=> 0
(product #{2 3 4})  ;=> 24 ; works for sets too!
quit
(empty? [])
(rest [])
(use 'recursion :reload)
(singleton? [])
(singleton? [1])
(singleton? [1, 2])
(singleton? [1 2])
(singleton? '())
(singleton? '(1 2 3 4 5))
(singleton? '(1))
(first '())
(use 'recursion :reload)
(my-last [1 2 3])
(my-last [1 2])
(my-last [1])
(my-last [3 2 1])
(my-last [3])
(my-last [])
(use 'recursion :reload)
(my-last [])
(use 'recursion :reload)
(my-last [])
(my-last [3 2 1])
(first [])
(empty? (first []))
(use 'recursion :reload)
(my-last [3 2 1])
(use 'recursion :reload)
(my-last [3 2 1])
(empty? (first []))
(my-last [])
(use 'recursion :reload)
(max-element [2 4 1 4]) ;=> 4
(max-element [2])       ;=> 2
(max-element [])        ;=> nil
(max-element [2 4])
(max-element [2 []])
(max-element [])
(use 'recursion :reload)
(max-element [2 4])
(max-element [2 []])
(max-element [2 4])
(use 'recursion :reload)
(seq-max [1] [1 2])   ;=> [1 2]
(seq-max [1 2] [3 4]) 
(count [1 2])
(count (1 2))
(use 'recursion :reload)
(count (1 2))
(count [1 2])
(seq-max [1 2] [3 4]) 
(seq-max '(1 2))
(seq-max '(1 2) '(1 2 3))
