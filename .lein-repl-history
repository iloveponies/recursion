    (= n 0) 0
    (= n 1) 1
    :else (+ (fib (dec n)) (fib (- n 2)))
    ))
(defn my-repeat [how-many-times what-to-repeat]
  (if (<= how-many-times 0)
    '()
    (cons what-to-repeat (my-repeat (deat-to-repeat))
    ))
(defn my-range [up-to]
  (cond
    (<= up-to 0) '()
    (= up-to 1) '(0)
    :else (cons (dec up-to)(my-range (dec up-to)))
    ))
           
(defn tails [a-seq]
  (if (empty? a-seq)
    (cons a-seq '())
    (cons a-seq (tails (rest a-seq)))
    ))
(defn inits [a-seq]
  (map reverse (tails (reverse a-seq))))
(defn rotations [a-seq]
  (let [double-seq (concat a-seq a-seq)
        num (count a-seq)]
    (defn rotations-helper [b-seq]
      (if
          (= num (count b-seq))
        (list b-seq)
        (cons (take num b-seq) (rotations-helper (rest b-seq)))))
    (rotations-helper (rest double-seq))))
    
(defn my-frequencies-helper [freqs a-seq]
  (let [key (first a-seq)
        val (get freqs key)
        rem-seq (rest a-seq)]
    (if (empty? a-seq)
      freqs
      (if val
            (my-frequencies-helper (assoc freqs key (inc val)) rem-seq)
            (my-frequencies-helper (assoc freqs key 1) rem-seq)
            ))))
(defn my-frequencies [a-seq]
   (my-frequencies-helper-frequencies [a-map]
  (if (empty? a-map)
    nil
    (let [tuple (first a-map)]
    (concat (my-repeat (second tuple) (first tuple)) (un-frequencies (rest a-map))))
    ))
(defn my-take [n coll]
  (if (or (empty? coll) (= n 0))
    '()
    (cons (first coll) (my-take (dec n) (rest coll)))
    ))
(defn my-drop [n coll]
  (if (= n 0)
    coll
    (my-drop (dec n) (rest coll))
    ))
(defn halve [a-seq]
  (let [splitpos (int (/ (count a-seq) 2))]
    (cons (my-take splitpos a-seq) (cons (my-drop splitpos a-seq) '()))
    ))
(defn seq-merge [a-seq b-seq]
  (cond
    (empty? a-seq) b-seq
    (empty? b-seq) a-seq
    :else
    (let
        [a-val (first a-seq)
         b-val (first b-seq)]
      (if (<= a-val b-val)
        (cons a-val (seq-merge (rest a-seq) b-seq))
        (cons b-val (seq-merge a-seq (rest b-seq)))
        ))))
(defn merge-sort [a-seq]
  (if (empty? (rest a-seq))
    a-seq
   (let [halves (halve a-seq)
          firsthalf (first halves)
          secondhalf (second halves)]
      (seq-merghalf) (merge-sort secondhalf))
      )))
(defn split-into-monotonics [a-seq]
  (reverse (map reverse
       (loop [acc nil
              mon nil
              seq1 a-seq
              dirup nil
            ]
         (cond
           (empty? seq1) (cons mon acc)
           (and (empty? (rest seq1)) (empty? mon)) (recur acc (cons (first seq1) nil) (rest seq1) dirup) 
           (or (empty? (rest seq1)) (and (not dirup) (< (first seq1) (second seq1)))) (recur acc (cons (first seq1) mon) (rest seq1) "up")
            (or (empty? (rest seq1)) (and (not dirup) (> (first seq1) (second seq1)))) (recur acc (cons (first seq1) mon) (rest seq1) "down")
           (or (empty? (rest seq1)) (and (= dirup "up") (< (first seq1) (second seq1)))) (recur acc (cons (first seq1) mon) (rest seq1) dirup)
           (or (empty? (rest seq1)) (and (= dirup "down") (> (first seq1) (second seq1)))) (recur acc (cons (first seq1) mon) (rest seq1) dirup)
           :else (recur (cons (cons (first seq1) mon) acc) nil (rest seq1) nil)
    
)
(defn rotations [a-seq]
  (let [double-seq (concat a-seq a-seq)
        num (count a-seq)]
    (defn rotations-helper [b-seq]
      (if
          (= num (count b-seq))
        (list b-seq)
        (cons (take num b-seq) (rotations-helper (rest b-seq)))))
    (rotations-helper (rest double-seq))))
(rotations #{5 3})
(rotations #{1 5 3})
(fn [x] (cons (first x) (rotations (rest x))) #{1 3 5})
((fn [x] (cons (first x) (rotations (rest x)))) #{1 3 5})
(map (fn [x] (disj #{1 5 3} x)) #{1 5 3})
(defn permutations [a-set]
  (map (fn [x]
         (let [remaining (disj a-set x)]
           (map (fn [rem] (concat x rem )) (rotations remset))
           )) a-set ))
(defn permutations [a-set]
  (map (fn [x]
         (let [remaining (disj a-set x)]
           (map (fn [rem] (concat x rem )) (rotations remaining))
           )) a-set ))
(permutations #{1 5 3})
(concat 5 (1 3))
(cons 5 (1 3))
(cons 5 '(1 3))
(defn permutations [a-set]
  (map (fn [x]
         (let [remaining (disj a-set x)]
           (map (fn [rem] (cons x rem )) (rotations remaining))
           )) a-set ))
(permutations #{1 5 3})
(defn permutations [a-set]
  (concat
   (map (fn [x]
         (let [remaining (disj a-set x)]
           (map (fn [rem] (cons x rem )) (rotations remaining))
           )) a-set )
   ))
(permutations #{1 5 3})
(def t4 (permutations #{1 5 3}))
(count t4)
(first t4)
(second t4)
(concat (first t4) (second t4))
(concat t4)
(map concat t4)
(reduce t4)
(reduce concat t4)
(defn permutations [a-set]
  (reduce concat
          (map (fn [x]
         (let [remaining (disj a-set x)]
           (map (fn [rem] (cons x rem )) (rotations remaining))
           )) a-set )
   ))
(permutations #{1 5 3 })
(permutations #{})
;=> (())
(permutations #{1 5 3})
(empty? #{})
(defn permutations [a-set]
  (if (empty? a-set)
    '()
   (reduce concat
          (map (fn [x]
         (let [remaining (disj a-set x)]
           (map (fn [rem] (cons x rem )) (rotations remaining))
           )) a-set )
   )))
(permutations #{})
(defn permutations [a-set]
  (if (empty? a-set)
    ('())
   (reduce concat
          (map (fn [x]
         (let [remaining (disj a-set x)]
           (map (fn [rem] (cons x rem )) (rotations remaining))
           )) a-set )
   )))
(permutations #{})
(defn permutations [a-set]
  (if (empty? a-set)
    '()
   (reduce concat
          (map (fn [x]
         (let [remaining (disj a-set x)]
           (map (fn [rem] (cons x rem )) (rotations remaining))
           )) a-set )
   )))
(permutations #{1 2 3 4 5})
(permutations #{1 2 3})
(permutations #{1 5 3})
(def s #{})
(def s #{1 2})
(conj s 3)
(conj s 1)
(def s #{})
s
(conj s #{})
(conj (conj s #{}) #{1})
(conj (conj s #{}) #{1})(defn powerset [a-set]
  (defn powerset-helper [set acc]
   if (empty? set)
    acc
    (powerset-helper (disj set (first set)) (conj (conj acc (first set)) (disj set (first set))))
    )
  (map powerset-helper a-set #{}))
(defn powerset [a-set]
  (defn powerset-helper [set acc]
   if (empty? set)
    acc
    (powerset-helper (disj set (first set)) (conj (conj acc (first set)) (disj set (first set))))
    )
  (map powerset-helper a-set #{}))
(defn powerset [a-set]
  (defn powerset-helper [set acc]
   (if (empty? set)
    acc
    (powerset-helper (disj set (first set)) (conj (conj acc (first set)) (disj set (first set))))
    ))
  (map powerset-helper a-set #{}))
 (powerset #{1 4 3})
(defn powerset [a-set]
  (defn powerset-helper [set acc]
   (if (empty? set)
    acc
    (powerset-helper (disj set (first set)) (conj (conj acc (first set)) (disj set (first set))))
    ))
  (reduce powerset-helper a-set #{}))
(powerset #{1 2 3})
(powerset #{1 2})
(defn powerset [a-set]
  (defn powerset-helper [set acc]
   (if (empty? set)
    acc
    (powerset-helper (disj set (first set)) (conj (conj acc (first set)) (disj set (first set))))
    ))
  (reduce powerset-helper a-set #{a-set}))
(powerset #{1 2 3 4})
(powerset #{1 2 3})
(first #{1 2 3}})
(first #{1 2 3})
(first #{2 3})
(set 1)
(set '(1))
(map (fn [x] (set '(x))) '(1 2 3))
(map (fn [x] (set (x))) '(1 2 3))
(map (fn [x] (set x)) '(1 2 3))
(map (fn [x] (set (list x))) '(1 2 3))
(conj #{#{1}} #{3}) 
(disj (conj #{#{1}} #{3}) 3)
(disj (conj #{#{1}} #{3}) #{3})
(defn powerset [a-set]
  (defn powerset-helper [set acc]
    (if (empty? set)
      acc
    (let [elem (first set)
          remaining (disj set elem)]
      (powerset-helper remaining (conj (conj acc (set (list elem))) remaining))
      )))
  (powerset-helper a-set #{}))
(powerset #{1 4 3})
(defn powerset [a-set]
  (defn powerset-helper [set acc]
    (if (empty? set)
      acc
    (let [elem (first set)
          remaining (disj set elem)]
      (conj (conj (conj acc (set (list elem))) remaining) (powerset-helper remaining acc)  )
      )))
  (powerset-helper a-set #{}))
(powerset #{1 4 3})
(defn powerset [a-set]
  (defn powerset-helper [elem set acc]
    (if (empty? set)
      acc
                                        ; (let [elem (first set)
                                        ;       remaining (disj set elem)]
      (conj (conj (conj acc (set (list elem))) set) (map (fn [x] (powerset-helper x (disj set x) acc)) set))
      ))
  (map (fn [x] (powerset-helper x (disj a-set x) #{})) a-set ))
(powerset #{1 3 4})
(defn powerset [a-set]
  (defn powerset-helper [elem set acc]
    (if (empty? set)
      acc
                                        ; (let [elem (first set)
                                        ;       remaining (disj set elem)]
      (set (conj (conj (conj acc (set (list elem))) set) (map (fn [x] (powerset-helper x (disj set x) acc)) set)))
      ))
  (map (fn [x] (powerset-helper x (disj a-set x) #{a-set})) a-set ))
(powerset #{1 3 4})
(defn powerset [a-set]
  (defn powerset-helper [elem set acc]
    (if (empty? set)
      acc
       (conj (conj (conj acc (set (list elem))) set) (map (fn [x] (powerset-helper x (disj set x) acc)) set))
      ))
  (map (fn [x] (powerset-helper x (disj a-set x) #{a-set})) a-set ))
(powerset #{1 3 4})
(def t5 (powerset #{1 3 4}))
(count t5)
(first t5)
(defn powerset [a-set]
  (defn powerset-helper [elem set acc]
    (if (empty? set)
      acc
       (conj (conj (conj acc (set (list elem))) set) (map (fn [x] (powerset-helper x (disj set x) acc)) set))
      ))
  (reduce (fn [x] (powerset-helper x (disj a-set x) #{a-set})) a-set ))
(powerset #{1 3 4})
(concat t5)
(count (concat t5))
(count (reduce concat t5))
(reduce concat t5)
(disj (reduce concat t5) nil)
(count (reduce  t5))
(concat t5)
t5
(first t5)
(count (first t5))
(first (first t5))
(second (first t5))
  (defn powerset-helper [elem set acc]
    (if (empty? set)
      acc
       (conj (conj (conj acc (set (list elem))) set) (map (fn [x] (powerset-helper x (disj set x) acc)) set))
      ))
(reduce  (fn [x] (powerset-helper x (disj a-set x) #{a-set})) a-set )
(def a-set #{1 3 4})
(reduce  (fn [x] (powerset-helper x (disj a-set x) #{a-set})) a-set )
(defn powerset [a-set]
  (defn powerset-helper-map [m-set acc]
    (map (fn [x] (powerset-helper x (disj m-set x) acc)) m-set))
  (defn powerset-helper [elem set1 acc]
    (if (empty? set1)
      acc
      (let [newacc (conj (conj acc elem) set1)]
        (powerset-helper-map set1 newacc))))
  (powerset-helper-map a-set #{a-set}))
(powerset #{1 3 4})
(count (powerset #{1 3 4}))
(reduce conj (powerset #{1 3 4}))
(count (reduce conj (powerset #{1 3 4})))
(count (map conj (powerset #{1 3 4})))
(count (map concat (powerset #{1 3 4})))
(first (powerset #{1 4 3})
)
(count (first (powerset #{1 4 3})))
(first (first (powerset #{1 4 3})))
(second (first (powerset #{1 4 3})))
(count (second (first (powerset #{1 4 3})))
)
(defn powerset [a-set]
  (defn powerset-helper-map [m-set acc]
    (map (fn [x] (powerset-helper x (disj m-set x) acc)) m-set))
  (defn powerset-helper [elem set1 acc]
    (if (empty? set1)
      acc
      (let [newacc (conj (conj acc #{elem}) set1)]
        (powerset-helper-map set1 newacc))))
  (powerset-helper-map a-set #{a-set}))
(powerset #{1 2 3})
(count (powerset #{1 2 3}))
(first (powerset #{1 2 3}))
(second (powerset #{1 2 3}))
(def t5 (powerset #{1 2 3}))
t5
(map conj t5)
(reduce conj  t5)
(map (reduce conj  t5))
(count (reduce conj t5))
(first (reduce conj t5))
t5
(defn powerset [a-set]
  (defn powerset-helper-map [m-set acc]
    (reduce (fn [x] (powerset-helper x (disj m-set x) acc)) m-set))
  (defn powerset-helper [elem set1 acc]
    (if (empty? set1)
      acc
      (let [newacc (conj (conj acc #{elem}) set1)]
        (powerset-helper-map set1 newacc))))
  (powerset-helper-map a-set #{a-set}))
(powerset #{1 4 3})
(powerset #{})
(powerset #{1})
(powerset #{1 2})
(powerset #{1 2 3})
(def t5 (powerset #{1 2 3}))
(defn powerset [a-set]
  (defn powerset-helper-map [m-set acc]
    (map (fn [x] (powerset-helper x (disj m-set x) acc)) m-set))
  (defn powerset-helper [elem set1 acc]
    (if (empty? set1)
      acc
      (let [newacc (conj (conj acc #{elem}) set1)]
        (powerset-helper-map set1 newacc))))
  (powerset-helper-map a-set #{a-set}))
(powerset #{1 2 34})
(powerset #{1 2})
(powerset #{1})
(powerset #{})
(first (powerset #{1}))
(first (powerset #{1 2}))
(second (powerset #{1 2}))
(def t2 (powerset #{1 2}))
t3
t2
(defn redset [set1 set2]
(map (fn [x] (conj set2 x)) set1))
(redset #{1} #{1 2})
(redset #{1 3} #{1 2 4})
(redset #{3} #{1 2 4})
(doc map)
(Doc map)
(Docs map)
(docs map)
(defn collater [elem acc]
(conj #{elem} acc))
(map collater #{1 2 3} #{})
(defn powerset [a-set]
  (defn powerset-helper [elem set1 acc]
    (if (empty? set1)
      acc
      (conj (conj acc #{elem}) set1)
      ))
  (map (fn [x] (powerset-helper x (disj a-set x) #{a-set})) a-set))
(powerset #{! 2})
(powerset #{1 2})
(powerset #{1 2 3})
(count (powerset #{1 2 3}))
(first (powerset #{1 2 3}))
(first (powerset #{1 2 3 4}))
(defn powerset [a-set]
  (defn powerset-helper [elem set1 acc]
    (if (empty? set1)
      acc
      (conj (conj acc #{elem}) set1)
      ))
  (map (fn [x acc] (conj (powerset-helper x (disj a-set x) #{a-set}) acc )  a-set #{})))
(powerset #{1 2})
(defn powerset [a-set]
  (defn powerset-helper [elem set1 acc]
    (if (empty? set1)
      acc
      (conj (conj acc #{elem}) set1)
      ))
  (reduce (fn [x acc] (conj (powerset-helper x (disj a-set x) #{a-set}) acc )  a-set #{})))
(powerset #{1 2})
(defn powerset [a-set]
  (defn powerset-helper [elem set1 acc]
    (if (empty? set1)
      acc
      (conj (conj acc #{elem}) set1)
      ))
  (map (fn [x] (powerset-helper x (disj a-set x) #{a-set})  a-set #{})))
(powerset #{1 2 3})
(defn powerset [a-set]
  (defn powerset-helper [elem set1 acc]
    (if (empty? set1)
      acc
      (conj (conj acc #{elem}) set1)
      ))
  (map (fn [x] (powerset-helper x (disj a-set x) #{a-set})  a-set)))
(powerset #{1 2 3})
(defn powerset [a-set]
  (defn powerset-helper [elem set1 acc]
    (if (empty? set1)
      acc
      (conj (conj acc #{elem}) set1)
      ))
  (map (fn [x] (powerset-helper x (disj a-set x) #{a-set})) a-set))
(powerset #{1 2 3})
(powerset #{1 2 3 4})
(powerset #{1 2})
t2
(reduce conj t2
)
(reduce (fn [x] (conj (second t2) x)) (first t2))
(merge t2)
(map merge t2)
(doc merge)
(powerset #{1 2})
(powerset #{1 2 3})
(defn powerset [a-set]
  (defn powerset-helper [elem set1 acc]
    (if (empty? set1)
      acc
      (conj (conj acc #{elem}) set1)
      ))
  (let [sets (map (fn [x] (powerset-helper x (disj a-set x) #{a-set})) a-set)]
                                        ;(reduce clojure.set/union (map (fn [x] (conj (second sets) x)) (first sets)))))
    (reduce clojure.set/union sets)))
(powerset #{ 1 2 3 })
git status
quit
