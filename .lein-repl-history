(use 'recursion)
(use 'recursion :reload)
(product [])        ;=> 1  ; special case
(product [1 2 3])   ;=> 6
(product [1 2 3 4]) ;=> 24
(product [0 1 2])   ;=> 0
(product #{2 3 4})  ;=> 24 ; works for sets too!
quit
(empty? [])
(rest [])
(use 'recursion :reload)
(singleton? [])
(singleton? [1])
(singleton? [1, 2])
(singleton? [1 2])
(singleton? '())
(singleton? '(1 2 3 4 5))
(singleton? '(1))
(first '())
(use 'recursion :reload)
(my-last [1 2 3])
(my-last [1 2])
(my-last [1])
(my-last [3 2 1])
(my-last [3])
(my-last [])
(use 'recursion :reload)
(my-last [])
(use 'recursion :reload)
(my-last [])
(my-last [3 2 1])
(first [])
(empty? (first []))
(use 'recursion :reload)
(my-last [3 2 1])
(use 'recursion :reload)
(my-last [3 2 1])
(empty? (first []))
(my-last [])
(use 'recursion :reload)
(max-element [2 4 1 4]) ;=> 4
(max-element [2])       ;=> 2
(max-element [])        ;=> nil
(max-element [2 4])
(max-element [2 []])
(max-element [])
(use 'recursion :reload)
(max-element [2 4])
(max-element [2 []])
(max-element [2 4])
(use 'recursion :reload)
(seq-max [1] [1 2])   ;=> [1 2]
(seq-max [1 2] [3 4]) 
(count [1 2])
(count (1 2))
(use 'recursion :reload)
(count (1 2))
(count [1 2])
(seq-max [1 2] [3 4]) 
(seq-max '(1 2))
(seq-max '(1 2) '(1 2 3))
(use 'recursion :reload)
(longest-sequence [[1 2] [] [1 2 3]]) ;=> [1 2 3]
(longest-sequence [[1 2]])            ;=> [1 2]
(longest-sequence [])                 ;=> nil
(longest-sequence [[1 2] [] [1 2 3] [1 2 3 4 5 6 7 8]])
(longest-sequence [[1] [] [1 2] [1 2 3] [1 2 3 4 5 6 7 8] [1 2 3 4]])
(use 'recursion :reload)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion :reload)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(use 'recursion :reload)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
 (cons (
            (pred? (first a-seq))
                   (first a-seq)
)
))
(cons (even? (first [1 3 5 8 9])) first [1 3 5 8 9])
(cons (even? (first [1 3 5 8 9]) first [1 3 5 8 9]))
(cons (even? (first [1 3 5 8 9])) first [1 3 5 8 9])
(cons ((even? (first [1 3 5 8 9])) first [1 3 5 8 9]))
(cons ((even? (first [1 3 5 8 9])) first [1 3 5 8 9]) '())
(use 'recursion :reload)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(use 'recursion :reload)
(sequence-contains? 3 [1 2 3]) ;=> true
(sequence-contains? 3 [4 7 9]) ;=> false
(sequence-contains? :pony [])  ;=> false
(use 'recursion :reload)
(my-take-while odd? [1 2 3 4])  ;=> (1)
(my-take-while odd? [1 3 4 5])  ;=> (1 3)
(my-take-while even? [1 3 4 5]) ;=> ()
(my-take-while odd? [])         ;=> ()
(set [])
(vec [])
(seq [])
(if (even? 2) ())
(use 'recursion :reload)
(my-take-while odd? [1 2 3 4])  ;=> (1)
(my-take-while odd? [1 3 4 5])  ;=> (1 3)
(my-take-while even? [1 3 4 5]) ;=> ()
(my-take-while odd? [])         ;=> ()
(use 'recursion :reload)
(my-take-while odd? [1 2 3 4])  ;=> (1)
(my-take-while odd? [1 3 4 5])  ;=> (1 3)
(my-take-while even? [1 3 4 5]) ;=> ()
(my-take-while odd? [])         ;=> ()
(use 'recursion :reload)
(my-take-while odd? [1 2 3 4])  ;=> (1)
(my-take-while odd? [1 3 4 5])  ;=> (1 3)
(my-take-while even? [1 3 4 5]) ;=> ()
(my-take-while odd? [])         ;=> ()
quit
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion :reload)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion :reload)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion :reload)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(use 'recursion)
(my-drop-while odd? [1 2 3 4])  ;=> (2 3 4)
(my-drop-while odd? [1 3 4 5])  ;=> (4 5)
(my-drop-while even? [1 3 4 5]) ;=> (1 3 4 5)
(my-drop-while odd? [])         ;=> ()
(use 'recursion)
(my-drop-while odd? [1 2 3 4])  ;=> (2 3 4)
(my-drop-while odd? [1 3 4 5])  ;=> (4 5)
(my-drop-while even? [1 3 4 5]) ;=> (1 3 4 5)
(my-drop-while odd? [])         ;=> ()
(use 'recursion :reload)
(my-drop-while odd? [1 2 3 4])  ;=> (2 3 4)
(my-drop-while odd? [1 3 4 5])  ;=> (4 5)
(my-drop-while even? [1 3 4 5]) ;=> (1 3 4 5)
(my-drop-while odd? [])         ;=> ()
(use 'recursion :reload)
(seq= [1 2 4] '(1 2 4))  ;=> true
(seq= [1 2 3] [1 2 3 4]) ;=> false
(seq= [1 3 5] [])        ;=> false
(use 'recursion :reload)
(seq= [1 2 4] '(1 2 4))  ;=> true
(seq= [1 2 3] [1 2 3 4]) ;=> false
(seq= [1 3 5] [])        ;=> false
(use 'recursion :reload)
      (println (str (first a-seq) " = " (first b-seq)))
(seq= [1 3 5] [])        ;=> false
(seq= [1 2 3] [1 2 3 4]) ;=> false
(use 'recursion :reload)
(seq= [1 2 nil] [1 2 nil])
(seq= [1 2 nil] [1 2])
(seq= [1 2 []] [1 2])
(use 'recursion :reload)
(seq= [1 2 []] [1 2])
(seq= [1 2 nil] [1 2])
(use 'recursion :reload)
(seq= [1 2 nil] [1 2])
(seq= [1 2 nil] [1 2 nil])
(seq= [1 3 5] [])        ;=> false
(empty? nil)
(empty? [nil])
(= [1 2 3] [1 2 3])
(= [1 2 3] [1 2])
(= [nil] [])
(not (empty? [1]))
(def a-seq [1 2])
(def b-seq [1 2])
 (or (and ((not (empty? a-seq)) (empty? b-seq)))
      (and ((empty? a-seq)) (not (empty? b-seq)))))
 (or (and ((not (empty? a-seq)) (empty? b-seq)))
      (and ((empty? a-seq)) (not (empty? b-seq))))
 (and ((not (empty? a-seq)) (empty? b-seq))
)
(empty? a-seq)
(empty? b-seq)
(and (not (empty? a-seq)) (empty? b-seq))
(use 'recursion :reload)
(seq= a-seq b-seq)
(def a-seq [1 2 nil])
(seq= a-seq b-seq)
(use 'recursion :reload)
(my-map + [1 2 3] [4 4 4])   ;=> (5 6 7)
(my-map + [1 2 3 4] [0 0 0]) ;=> (1 2 3)
(my-map + [1 2 3] [])        ;=> ()
(use 'recursion :reload)
(power 2 3)
(power 2 0)
(power 0 0)
expt
(expt 1 2)
(use 'clojure.math.numeric-tower)
(use 'clojure.math.*)
exp
pow
math.pow
(abs -1)
(.abs -1)
(def a = "a")
(def a "a")
(+ a 1)
a
(defn givenan [n]
)
(defn jaa [n d]
(if (zero? d) Double/NaN
(/ n d))
)
jaa
(jaa 1 2)
(jaa 1 0)
(defn palautaNaN
NaN)
(use 'recursion :reload)
(power 1 2)
(power 2 3)
(power 0 1)
(power 0 0)
(power 1 0)
(power 2 0)
(use 'recursion :reload)
(power 1 0)
(power 0 0)
(power 2 3)
(power 0 10)
(power 0 0)
(power 1 0)
(power 222 0)
(use 'recursion :reload)
(fib 0) ;=> 0
(fib 1) ;=> 1
(fib 2) ;=> 1
(fib 3) ;=> 2
(fib 4) ;=> 3
(fib 5) ;=> 5
(fib 6) ;=> 8
...
(fib 10) ;=> 55
(fib 10)
(fib -1)
(fib 1.1)
(fib 2/7)
(use 'recursion :reload)
(my-repeat 2 "lol")
(my-repeat 1 "lol")
(my-repeat 1 2)
(use 'recursion :reload)
(my-repeat 1 2)
(my-repeat 1 "lol")
(cons 1 2)
(cons set 1)
(set 1)
seq
(seq 1)
(conj 1 2)
(conj 1 ())
(conj 1 '())
(cons 1 '())
(cons '1 2)
(cons '1 '2)
(cons (seq 1) 2)
(cons (seq 1))
(seq 1)
(seq 1 ())
(cons 1 ())
(use 'recursion :reload)
(my-repeat 3 "l")
(cons 1 (lazy-seq (2)))
(cons 1 (lazy-seq 2))
(conj 1 (seq 2))
(conj 1 2)
seq
(seq 1)
(cons 1 ())
(cons 2 (cons 1 ()))
(cons (2 ()))
(cons 2 (cons 1 ())
)
(use 'recursion :reload)
(my-repeat 3 "lol")
(cons (2 ()) (1 ()))
(cons 2 (1 ()))
(use 'recursion :reload)
(cons 2 (1 ()))
(my-repeat 3 "lol")
(use 'recursion :reload)
my-repeat
(my-repeat 3 "lol")
(use 'recursion :reload)
(my-repeat 3 "lol")
(cons 1 ())
(my-repeat 0 "lol")
(dec 1)
(cons "lol" ())
(use 'recursion :reload)
(my-repeat 0 "lol")
(my-repeat 3 "lol")
(use 'recursion :reload)
(my-repeat 3 "lol")
(use 'recursion :reload)
(my-repeat 3 "lol")
(my-repeat 0 "lol")
(use 'recursion :reload)
(my-repeat 0 "lol")
(my-repeat 3 "lol")
(use 'recursion :reload)
(my-repeat 3 "lol")
(use 'recursion :reload)
(my-filter odd [1 2 3 4])
(my-filter odd? [1 2 3 4])
(use 'recursion :reload)
(my-filter odd? [1 2 3 4])
(use 'recursion :reload)
(my-filter odd? [1 2 3 4])
(use 'recursion :reload)
(my-filter odd? [1 2 3 4])
(use 'recursion :reload)
(my-filter odd? [1 2 3 4])
(use 'recursion :reload)
(my-range 0)
(my-range 1)
(use 'recursion :reload)
(my-range 1)
(my-range 0)
(use 'recursion :reload)
(tails [1 2 3 4])
(use 'recursion :reload)
(tails [1 2 3 4])
(use 'recursion :reload)
(tails [1 2 3 4])
(use 'recursion :reload)
(tails [1 2 3 4])
(use 'recursion :reload)
(tails [1 2 3 4])
(use 'recursion :reload)
(tails [1 2 3 4])
(vector [1 2 3 4])
(seq [1 2 3 4])
(vector [1 2 3 4])
(use 'recursion :reload)
(tails [1 2 3 4])
(use 'recursion :reload)
(tails [1 2 3 4])
(use 'recursion :reload)
(tails [1 2 3 4])
(use 'recursion :reload)
(tails [1 2 3 4])
(cons () ())
(cons ((1)) ())
(cons () (1))
(cons ((1)) ())
(cons () ((1)))
(cons '() ((1)))
((1))
(cons 1 ())
(cons () (1))
(cons () '())
(use 'recursion :reload)
(tails [1 2 3 4])
(use 'recursion :reload)
(tails [1 2 3 4])
(use 'recursion :reload)
(tails [1 2 3 4])
(inits [1 2 3 4])
(tails [1 2 3 4])
(inits [1 2 3 4])
(use 'recursion :reload)
(inits [1 2 3 4])
