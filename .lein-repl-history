(use 'recursion)
(use 'recursion :reload)
(product [])        ;=> 1  ; special case
(product [1 2 3])   ;=> 6
(product [1 2 3 4]) ;=> 24
(product [0 1 2])   ;=> 0
(product #{2 3 4})  ;=> 24 ; works for sets too!
quit
(empty? [])
(rest [])
(use 'recursion :reload)
(singleton? [])
(singleton? [1])
(singleton? [1, 2])
(singleton? [1 2])
(singleton? '())
(singleton? '(1 2 3 4 5))
(singleton? '(1))
(first '())
(use 'recursion :reload)
(my-last [1 2 3])
(my-last [1 2])
(my-last [1])
(my-last [3 2 1])
(my-last [3])
(my-last [])
(use 'recursion :reload)
(my-last [])
(use 'recursion :reload)
(my-last [])
(my-last [3 2 1])
(first [])
(empty? (first []))
(use 'recursion :reload)
(my-last [3 2 1])
(use 'recursion :reload)
(my-last [3 2 1])
(empty? (first []))
(my-last [])
(use 'recursion :reload)
(max-element [2 4 1 4]) ;=> 4
(max-element [2])       ;=> 2
(max-element [])        ;=> nil
(max-element [2 4])
(max-element [2 []])
(max-element [])
(use 'recursion :reload)
(max-element [2 4])
(max-element [2 []])
(max-element [2 4])
(use 'recursion :reload)
(seq-max [1] [1 2])   ;=> [1 2]
(seq-max [1 2] [3 4]) 
(count [1 2])
(count (1 2))
(use 'recursion :reload)
(count (1 2))
(count [1 2])
(seq-max [1 2] [3 4]) 
(seq-max '(1 2))
(seq-max '(1 2) '(1 2 3))
(use 'recursion :reload)
(longest-sequence [[1 2] [] [1 2 3]]) ;=> [1 2 3]
(longest-sequence [[1 2]])            ;=> [1 2]
(longest-sequence [])                 ;=> nil
(longest-sequence [[1 2] [] [1 2 3] [1 2 3 4 5 6 7 8]])
(longest-sequence [[1] [] [1 2] [1 2 3] [1 2 3 4 5 6 7 8] [1 2 3 4]])
(use 'recursion :reload)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion :reload)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(use 'recursion :reload)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
 (cons (
            (pred? (first a-seq))
                   (first a-seq)
)
))
(cons (even? (first [1 3 5 8 9])) first [1 3 5 8 9])
(cons (even? (first [1 3 5 8 9]) first [1 3 5 8 9]))
(cons (even? (first [1 3 5 8 9])) first [1 3 5 8 9])
(cons ((even? (first [1 3 5 8 9])) first [1 3 5 8 9]))
(cons ((even? (first [1 3 5 8 9])) first [1 3 5 8 9]) '())
(use 'recursion :reload)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(use 'recursion :reload)
(sequence-contains? 3 [1 2 3]) ;=> true
(sequence-contains? 3 [4 7 9]) ;=> false
(sequence-contains? :pony [])  ;=> false
(use 'recursion :reload)
(my-take-while odd? [1 2 3 4])  ;=> (1)
(my-take-while odd? [1 3 4 5])  ;=> (1 3)
(my-take-while even? [1 3 4 5]) ;=> ()
(my-take-while odd? [])         ;=> ()
(set [])
(vec [])
(seq [])
(if (even? 2) ())
(use 'recursion :reload)
(my-take-while odd? [1 2 3 4])  ;=> (1)
(my-take-while odd? [1 3 4 5])  ;=> (1 3)
(my-take-while even? [1 3 4 5]) ;=> ()
(my-take-while odd? [])         ;=> ()
(use 'recursion :reload)
(my-take-while odd? [1 2 3 4])  ;=> (1)
(my-take-while odd? [1 3 4 5])  ;=> (1 3)
(my-take-while even? [1 3 4 5]) ;=> ()
(my-take-while odd? [])         ;=> ()
(use 'recursion :reload)
(my-take-while odd? [1 2 3 4])  ;=> (1)
(my-take-while odd? [1 3 4 5])  ;=> (1 3)
(my-take-while even? [1 3 4 5]) ;=> ()
(my-take-while odd? [])         ;=> ()
quit
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion :reload)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion :reload)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(my-filter even? [1 3 5 7]) ;=> ()
(use 'recursion :reload)
(my-filter odd? [1 2 3 4]) ;=> (1 3)
(my-filter (fn [x] (> x 9000)) [12 49 90 9001]) ;=> (9001)
(use 'recursion)
(my-drop-while odd? [1 2 3 4])  ;=> (2 3 4)
(my-drop-while odd? [1 3 4 5])  ;=> (4 5)
(my-drop-while even? [1 3 4 5]) ;=> (1 3 4 5)
(my-drop-while odd? [])         ;=> ()
(use 'recursion)
(my-drop-while odd? [1 2 3 4])  ;=> (2 3 4)
(my-drop-while odd? [1 3 4 5])  ;=> (4 5)
(my-drop-while even? [1 3 4 5]) ;=> (1 3 4 5)
(my-drop-while odd? [])         ;=> ()
(use 'recursion :reload)
(my-drop-while odd? [1 2 3 4])  ;=> (2 3 4)
(my-drop-while odd? [1 3 4 5])  ;=> (4 5)
(my-drop-while even? [1 3 4 5]) ;=> (1 3 4 5)
(my-drop-while odd? [])         ;=> ()
(use 'recursion :reload)
(seq= [1 2 4] '(1 2 4))  ;=> true
(seq= [1 2 3] [1 2 3 4]) ;=> false
(seq= [1 3 5] [])        ;=> false
(use 'recursion :reload)
(seq= [1 2 4] '(1 2 4))  ;=> true
(seq= [1 2 3] [1 2 3 4]) ;=> false
(seq= [1 3 5] [])        ;=> false
(use 'recursion :reload)
      (println (str (first a-seq) " = " (first b-seq)))
(seq= [1 3 5] [])        ;=> false
(seq= [1 2 3] [1 2 3 4]) ;=> false
(use 'recursion :reload)
(seq= [1 2 nil] [1 2 nil])
(seq= [1 2 nil] [1 2])
(seq= [1 2 []] [1 2])
(use 'recursion :reload)
(seq= [1 2 []] [1 2])
(seq= [1 2 nil] [1 2])
(use 'recursion :reload)
(seq= [1 2 nil] [1 2])
(seq= [1 2 nil] [1 2 nil])
(seq= [1 3 5] [])        ;=> false
(empty? nil)
(empty? [nil])
(= [1 2 3] [1 2 3])
(= [1 2 3] [1 2])
(= [nil] [])
(not (empty? [1]))
(def a-seq [1 2])
(def b-seq [1 2])
 (or (and ((not (empty? a-seq)) (empty? b-seq)))
      (and ((empty? a-seq)) (not (empty? b-seq)))))
 (or (and ((not (empty? a-seq)) (empty? b-seq)))
      (and ((empty? a-seq)) (not (empty? b-seq))))
 (and ((not (empty? a-seq)) (empty? b-seq))
)
(empty? a-seq)
(empty? b-seq)
(and (not (empty? a-seq)) (empty? b-seq))
(use 'recursion :reload)
(seq= a-seq b-seq)
(def a-seq [1 2 nil])
(seq= a-seq b-seq)
